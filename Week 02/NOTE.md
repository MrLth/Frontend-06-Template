# 性能优化

1. 使用数组实现 **队列** 或者 **栈** 代替递归

2. 从数组中删除元素时，如果不在意元素间的顺序，将需要删除元素与数组最后一位元素交换，再删除最后一位元素

   *Array.prototype.splice 删除数组元素时，会引起删除元素索引之后的数组元素更新索引*

# 数据结构及算法

1. 广度优先搜索使用 **队列**，深度优先搜索使用 **栈**

## 1. A* 寻路

1. 启发式搜索
   		启发式搜索就是在状态空间中的搜索对每一个搜索的位置进行评估，得到最好的位置，再从这个位置进行搜索直到目标。这样可以省略大量无畏的搜索路径，提到了效率。在启发式搜索中，对位置的估价是十分重要的。采用了不同的估价可以有不同的效果。

2. A* 算法的位置估价等式： **`F = G + H`**

   - G，从起点A，沿着产生的路径，移动到指定方格的移动耗费
   - H，从指定方格移动到终点B的预估耗费

3. 相关资料

   [[算法：Astar寻路算法改进，双向A*寻路算法](https://www.cnblogs.com/anrainie/p/4923817.html)]

   [[A*算法入门]](https://baike.baidu.com/reference/215793/b45aeMpVOUYVY-XJzpdvlcd6WTG4oj4DJcewy4VQq67exQ976_ODmzTi41NNwNl6C3oiaU5W10LpjGYG75MfLYaLyT4szY13y5vI7DlFZjksLdPLL4LmPQ)

   [[常用的一些路径规划算法]](https://github.com/zhm-real/PathPlanning)

## 2. 二叉堆

1. 完全二叉树(Complete Binary Tree),
   完全二叉树有一个很优秀的性质，就是可以被存储在一片连续的数组空间中（一般下标从 1 开始，方便计算根节点的子节点下标）

   **如果父节点编号是 i，其左子节点的编号就是 2 * i，右子节点的编号就是 2 * i + 1。**

   <img src="https://static001.geekbang.org/resource/image/be/f2/be70f37ca4ab58fbdcf3d01dd1b5c3f2.jpg" alt="2" style="zoom:25%;" />

2. 堆结构的定义
   堆可以分为两类，小顶堆和大顶堆。
   如果在一棵完全二叉树中，每个父节点的值都要小于其两个子节点的值，我们就管这种结构叫做小顶堆。相对应地，大顶堆就是每个父节点的值要大于其两个子节点的值。

3. 插入新元素

   1. 元素放置：将这个新的元素，放置到整个数组的最后一位
   2. 向上调整：从堆底位置开始，在当前元素值小于其父节点值的时候，交换子节点与父节点值的位置，就这样一直向上调整，直到当前节点大于父节点的值或者调整到了堆顶

4. 删除最值元素

   1. 元素覆盖：用堆的最后一位元素，覆盖掉堆顶元素
   2. 向下调整：从堆顶位置开始，从当前元素的子节点中，找到小于当前元素值的子节点（最小的那个），并将此子节点与父节点的位置交换。就这样一直向下调整，直到当前节点大于其下所有子节点的值或者调整到了底

